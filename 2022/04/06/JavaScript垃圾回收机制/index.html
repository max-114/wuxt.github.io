<!DOCTYPE html>
<html>
<meta  lang="en" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <link rel="icon" href="/img/logo.png">
  <title>wuxt</title>
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_vpj3dq9ceqa.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  <link rel="preload" href="//cdn.jsdelivr.net/npm/fslightbox@3.1.0/index.min.js" as="script">
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_vpj3dq9ceqa.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
  
  
  
  <link href="/js/lib/prism/prism-tomorrow.min.css" rel="stylesheet" data-prism="prism-tomorrow">
  
  
  
<link rel="stylesheet" href="/js/lib/prism/prism-line-numbers.min.css">

  
  
  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="/img/logo.png">
      
      <span class="navbar-logo-dsc">wuxt</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">Home </a>
    
    <a href="/archives" class="navbar-menu-item">Archive </a>
    
    <a href="/tags" class="navbar-menu-item">Tags </a>
    
    <a href="/categories" class="navbar-menu-item">Categories </a>
    
    <a href="/about" class="navbar-menu-item">About </a>
    
    <a href="/links" class="navbar-menu-item">Friends </a>
    
    <a class="navbar-menu-item darknavbar" id="dark"><i class="iconfont icon-weather"></i></a>
  </div>
</nav>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      JavaScript垃圾回收机制
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2022-04-06T13:31:10.000Z" style="display: flex; align-items: center;">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2022-04-06</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/JavaScript/" class="post-meta-link">JavaScript</a>
    
    
    
    <span class="dot"></span>
    <span>3.6k words</span>
    
  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/原理/" class="post-meta-link">原理</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <h2 id="JavaScript-垃圾回收机制"><a href="#JavaScript-垃圾回收机制" class="headerlink" title="JavaScript 垃圾回收机制"></a>JavaScript 垃圾回收机制</h2><h2 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JavaScript 中内存管理的主要概念是<strong>可达性</strong>。</p>
<p>拥有 <strong>“可达性”</strong> 值就是那些以某种方式可访问或可用的值，保证它们被存储在内存中。</p>
<p><strong>1. 有一组基本的固有可达值，由于显而易见的原因无法删除。例如:</strong></p>
<ul>
<li>本地函数的局部变量和参数</li>
<li>当前处于调用链上的其他函数的变量和参数</li>
<li>全局变量</li>
<li>还有一些其他的，内部的（变量或函数）</li>
</ul>
<p><strong>2. 如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。</strong></p>
<p>例如，如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为<strong>可达性</strong>， 它引用的那些也是可以访问的。</p>
<p>JavaScript 引擎中有一个后台进程称为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">垃圾回收器</a>，它监视所有对象，并删除那些不可访问的对象。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// user 具有对象的引用</span>
<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'John'</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809170332.png" alt="user" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809170332.png" class="lozad post-image"></p>
<p>这里箭头表示一个对象引用。全局变量<code>“user”</code>引用对象 <code>&#123;name:“John”&#125;</code> (为了简洁起见，我们将其命名为<strong>John</strong>)。John 的 <code>“name”</code> 属性存储一个基本类型，因此它被绘制在对象中。</p>
<p>如果 <code>user</code> 的值被覆盖，则引用丢失:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">user <span class="token operator">=</span> <span class="token keyword">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809170503.png" alt="user=null" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809170503.png" class="lozad post-image"></p>
<p>现在 <strong>John</strong> 变成不可达的状态，没有办法访问它，没有对它的引用。垃圾回收器将丢弃 <strong>John</strong> 数据并释放内存。</p>
<h4 id="两个引用"><a href="#两个引用" class="headerlink" title="两个引用"></a>两个引用</h4><p>假设将引用从 <code>user</code> 复制到 <code>admin</code>:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// user具有对象的引用</span>
<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'John'</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">let</span> admin <span class="token operator">=</span> user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171005.png" alt="Tworeferences" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171005.png" class="lozad post-image"></p>
<p>现在如果做同样的事情:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">user <span class="token operator">=</span> <span class="token keyword">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>该对象仍然可以通过 <code>admin</code> 全局变量访问，所以它依然在内存中。如果也覆盖<code>admin</code>，那么它可以被释放。</p>
<h4 id="相互关联的对象"><a href="#相互关联的对象" class="headerlink" title="相互关联的对象"></a>相互关联的对象</h4><p>现在来看一个更复杂的例子， family 对象：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">marry</span><span class="token punctuation">(</span><span class="token parameter">man<span class="token punctuation">,</span> woman</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  woman<span class="token punctuation">.</span>husban <span class="token operator">=</span> man
  man<span class="token punctuation">.</span>wife <span class="token operator">=</span> woman

  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">father</span><span class="token operator">:</span> man<span class="token punctuation">,</span>
    <span class="token literal-property property">mother</span><span class="token operator">:</span> woman
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">let</span> family <span class="token operator">=</span> <span class="token function">marry</span><span class="token punctuation">(</span>
  <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'John'</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Ann'</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>函数 <code>marry</code> 通过给两个对象彼此提供引用来“联姻”它们，并返回一个包含两个对象的新对象。</p>
<p>产生的内存结构:</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171324.png" alt="marry" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171324.png" class="lozad post-image"></p>
<p>到目前为止，所有对象都是可访问的。</p>
<p>现在删除两个引用:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">delete</span> family<span class="token punctuation">.</span>father
<span class="token keyword">delete</span> family<span class="token punctuation">.</span>mother<span class="token punctuation">.</span>husband<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171404.png" alt="delete" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171404.png" class="lozad post-image"></p>
<p>仅仅删除这两个引用中的一个是不够的，因为所有对象仍然是可访问的。</p>
<p>但是如果我们把这两个都删除，那么我们可以看到 <strong>John</strong> 不再有传入的引用:</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171538.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171538.png" class="lozad post-image"></p>
<p>输出引用无关紧要。只有传入的对象才能使对象可访问，因此，<strong>John</strong> 现在是不可访问的，并将从内存中删除所有不可访问的数据。</p>
<p>垃圾回收之后：</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411221042.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411221042.png" class="lozad post-image"></p>
<h4 id="无法访问的数据块"><a href="#无法访问的数据块" class="headerlink" title="无法访问的数据块"></a>无法访问的数据块</h4><p>有可能整个相互连接的对象变得不可访问并从内存中删除。</p>
<p>源对象与上面的相同。然后:</p>
<pre class="line-numbers language-none"><code class="language-none">family &#x3D; null;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>内存中的图片变成:</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171753.png" alt="familyIsNull" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171753.png" class="lozad post-image"></p>
<p>这个例子说明了可达性的概念是多么重要。</p>
<p>很明显，John 和 Ann 仍然链接在一起，都有传入的引用。但这还不够。</p>
<p><code>“family”</code>对象已经从根上断开了链接，不再有对它的引用，因此下面的整个块变得不可到达，并将被删除。</p>
<h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><h3 id="标记-清除（Mark-Sweep）"><a href="#标记-清除（Mark-Sweep）" class="headerlink" title="标记 - 清除（Mark-Sweep）"></a>标记 - 清除（Mark-Sweep）</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>“标记 - 清除”</strong>为基本的垃圾回收算法，定期执行以下”垃圾回收”步骤:</p>
<ul>
<li><p>垃圾回收器获取根，遍历所有对象找可达对象（层级用递归进行操作），并</p>
<p>“标记”</p>
<p>(记住)它们。</p>
<ul>
<li>它访问并”标记”所有来自它们的引用。</li>
<li>然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。</li>
<li>以此类推，直到有未访问的引用(可以从根访问)为止。</li>
</ul>
</li>
<li><p>除标记的对象外，所有对象都被清楚并抹掉第一阶段的标记</p>
</li>
<li><p>回收相应空间，将回收的空间加到空闲链表中，方便后面的程序申请空间使用</p>
</li>
</ul>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>例如，对象结构如下:</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172307.png" alt="object" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172307.png" class="lozad post-image"></p>
<p>我们可以清楚地看到右边有一个“不可到达的块”。现在让我们看看<strong>“标记并清除”</strong>垃圾回收器如何处理它。</p>
<p><strong>第一步标记根</strong></p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172420.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172420.png" class="lozad post-image"></p>
<p><strong>然后标记他们的引用</strong></p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172431.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172431.png" class="lozad post-image"></p>
<p><strong>以及子孙代的引用</strong></p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172446.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172446.png" class="lozad post-image"></p>
<p>现在进程中不能访问的对象被认为是不可访问的，将被删除：</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172458.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172458.png" class="lozad post-image"></p>
<p>可以把这个过程想象成从根部洒下一大桶油漆，流经所有的参照物，并在所有可触及的对象上做标记。然后，未做标记的就会被清除。</p>
<p>这就是垃圾收集的工作原理。JavaScript 引擎应用了许多优化，使其运行得更快，并且不影响执行。</p>
<p>标记清除有一个问题，就是在清除之后，内存空间是不连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。</p>
<p><strong>优点</strong></p>
<p>相对于引用计数算法来说解决对象循环引用的问题，局部作用域里面的内容无法被标记，所以即使有引用还是会被清除掉</p>
<p><strong>缺点</strong></p>
<p>空间链表地址不连续（空间碎片化），不能进行空间最大化使用</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411130114.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411130114.png" class="lozad post-image"></p>
<blockquote>
<p>左边释放了<code>2</code>个字的空间，后边释放了<code>1</code>个字的空间，虽然看起来是释放了<code>3</code>个字的空间，但是地址是不连续的。如果要申请一个<code>1.5</code>字的空间，使用左边空间浪费了<code>0.5</code>，时候右边又不够，会造成无法最大化使用。</p>
</blockquote>
<h3 id="标记-整理（Mark-Compact）"><a href="#标记-整理（Mark-Compact）" class="headerlink" title="标记 - 整理（Mark-Compact）"></a>标记 - 整理（Mark-Compact）</h3><p>在 <strong>标记</strong> 和 <strong>清除</strong> 中间，添加了内存空间的 <strong>整理</strong></p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul>
<li>标记整理可以看做是标记清除的 <strong>增强</strong></li>
<li>标记阶段：与标记清除一致</li>
<li>整理阶段：清除钱先执行整理，移动对象位置，在地址上产生连续</li>
<li>清除阶段：与标记清除一致</li>
</ul>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p>开始会有很多活动对象和非活动对象，还有一些空闲空间，回收前先开始整理</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411130407.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411130407.png" class="lozad post-image"></p>
<p>整理之后要将非活动对象进行清除</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411130425.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411130425.png" class="lozad post-image"></p>
<p>最后就留出了整个的空闲空间</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411130451.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411130451.png" class="lozad post-image"></p>
<p><strong>优点</strong></p>
<p>相较标记清除算法减少了碎片化空间</p>
<p><strong>缺点</strong></p>
<ol>
<li>压缩过程的开销，需要多次搜索堆</li>
<li>不会立即回收垃圾对象，清除的时候程序是停止工作的。</li>
</ol>
<h3 id="引用计数（Reference-Counting）"><a href="#引用计数（Reference-Counting）" class="headerlink" title="引用计数（Reference Counting）"></a>引用计数（Reference Counting）</h3><p>这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span>
<span class="token comment">// 很显然，没有一个可以被垃圾收集</span>

<span class="token keyword">var</span> o2 <span class="token operator">=</span> o <span class="token comment">// o2变量是第二个对“这个对象”的引用</span>

o <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有</span>

<span class="token keyword">var</span> oa <span class="token operator">=</span> o2<span class="token punctuation">.</span>a <span class="token comment">// 引用“这个对象”的a属性</span>
<span class="token comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span>

o2 <span class="token operator">=</span> <span class="token string">'yo'</span> <span class="token comment">// 虽然最初的对象现在已经是零引用了，可以被垃圾回收了</span>
<span class="token comment">// 但是它的属性a的对象还在被oa引用，所以还不能回收</span>

oa <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// a属性的那个对象现在也是零引用了</span>
<span class="token comment">// 它可以被垃圾回收了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="限制：循环引用"><a href="#限制：循环引用" class="headerlink" title="限制：循环引用"></a>限制：循环引用</h4><p>该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
  <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
  o<span class="token punctuation">.</span>a <span class="token operator">=</span> o2 <span class="token comment">// o 引用 o2</span>
  o2<span class="token punctuation">.</span>a <span class="token operator">=</span> o <span class="token comment">// o2 引用 o</span>

  <span class="token keyword">return</span> <span class="token string">'azerty'</span>
<span class="token punctuation">&#125;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。可以这么做：</span>
o <span class="token operator">=</span> <span class="token keyword">null</span>
o2 <span class="token operator">=</span> <span class="token keyword">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>实际例子：</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> div
window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myDivElement'</span><span class="token punctuation">)</span>
  div<span class="token punctuation">.</span>circularReference <span class="token operator">=</span> div
  div<span class="token punctuation">.</span>lotsOfData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的例子里，<code>myDivElement</code> 这个 DOM 元素里的 <code>circularReference 属性</code>引用了 <code>myDivElement</code>，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从 DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 <code>lotsOfData</code> 属性)，而这个数据占用的内存将永远不会被释放。</p>
<h3 id="分代回收（Scavenge）"><a href="#分代回收（Scavenge）" class="headerlink" title="分代回收（Scavenge）"></a>分代回收（Scavenge）</h3><ul>
<li><strong>新生代</strong> —— 就是指存活时间较短的对象，例如：一个局部作用域中，只要函数执行完毕之后变量就会回收。</li>
<li><strong>老生代</strong> —— 就是指存活时间较长的对象，例如：全局对象，闭包变量数据。</li>
</ul>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p><code>V8</code>内存空间一分为二，分为新生代存储区和老生代存储区，如图：</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411132003.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411132003.png" class="lozad post-image"></p>
<ul>
<li>左边小空间用于存储新生代对象<ul>
<li><code>64bit</code>操作系统上不超过<code>32M</code></li>
<li><code>32bit</code>操作系统上不超过<code>16M</code></li>
</ul>
</li>
<li>右边较大空间用于存储老生代对象<ul>
<li><code>64bit</code>操作系统上不超过<code>1.6G</code></li>
<li><code>32bit</code>操作系统上不超过<code>700M</code></li>
</ul>
</li>
</ul>
<h4 id="新生代对象回收"><a href="#新生代对象回收" class="headerlink" title="新生代对象回收"></a>新生代对象回收</h4><h5 id="主要使用算法"><a href="#主要使用算法" class="headerlink" title="主要使用算法"></a>主要使用算法</h5><p>采用赋值算法 + 标记整理算法</p>
<h5 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h5><p>新生代内存区分为两个等大小空间，使用空间为<code>From</code>，空闲空间为<code>To</code>。</p>
<p>如果需要申请空间使用，回收步骤如下：</p>
<ol>
<li>首先会将所有活动对象存储于<code>From</code>空间，这个过程中<code>To</code>是空闲状态。</li>
<li>当<code>From</code>空间使用到一定程度之后就会触发<code>GC</code>操作，这个时候会进行标记整理对活动对象进行标记并移动位置将使用空间变得连续，便于后续不会产生碎片化空间。</li>
<li>将活动对象拷贝至<code>To</code>空间，拷贝完成之后活动空间就有了备份，这个时候就可以考虑回收操作了。</li>
<li>把<code>From</code>空间完成释放，回收完成</li>
<li>对<code>From</code>和<code>To</code>名称进行调换，继续重复之前的操作。</li>
</ol>
<blockquote>
<p>总结就是：<br><code>使用From</code> -&gt; <code>触发GC标记整理</code> -&gt; <code>拷贝到To</code> -&gt; <code>回收From</code> -&gt; <code>名称互换重复之前</code></p>
</blockquote>
<h5 id="晋升"><a href="#晋升" class="headerlink" title="晋升"></a>晋升</h5><p>拷贝的过程中某个对象的指代在老生代空间，就可能出现晋升。 <strong><code>晋升就是将新生代对象移动至老生代。</code></strong></p>
<p><strong>什么时候触发晋升操作?</strong></p>
<blockquote>
<ol>
<li>一轮<code>GC</code>之后还存活的新生代对象需要晋升</li>
<li>在拷贝过程中，<code>To</code>空间的使用率超过<code>25%</code>，将这次的活动对象都移动至老生代空间</li>
</ol>
</blockquote>
<p><strong>为什么是限制 To 的使用率呢?</strong></p>
<blockquote>
<p>将来回收操作是要把<code>From</code>空间的内容拷贝到<code>To</code>空间中进行交换，如果<code>To</code>的使用率太高，变成<code>From</code>之后新的对象就存不进去了。</p>
</blockquote>
<h4 id="回收老生代对象"><a href="#回收老生代对象" class="headerlink" title="回收老生代对象"></a>回收老生代对象</h4><h5 id="主要使用算法-1"><a href="#主要使用算法-1" class="headerlink" title="主要使用算法"></a>主要使用算法</h5><p>主要采用标记清除 <strong>（首要）</strong> 、标记整理、增量标记算法</p>
<ul>
<li><code>标记清除</code>：虽然使用标记清除会有空间碎片化的问题，但是标记清除提升的速度是很快的。</li>
<li><code>标记整理</code>：在晋升的时候且老生代区域的空间也不够容纳的时候，就会采用标记整理进行 <strong>空间优化</strong>。</li>
<li><code>增量标记</code>：将一整段的垃圾回收操作标记拆分成多个小段完成回收，主要是为了实现程序和垃圾回收的交替完成，这样进行 <strong>效率优化</strong> 带来的时间消耗更加的合理。</li>
</ul>
<h5 id="标记增量优化垃圾回收"><a href="#标记增量优化垃圾回收" class="headerlink" title="标记增量优化垃圾回收"></a>标记增量优化垃圾回收</h5><p>看图可以将垃圾回收分成两个部分，一个是程序的执行，一个是垃圾的回收。当垃圾回收的时候其实会阻塞程序的执行，所以中间会有空档期。</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411134207.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411134207.png" class="lozad post-image"></p>
<h5 id="新生代-VS-老生代"><a href="#新生代-VS-老生代" class="headerlink" title="新生代 VS 老生代"></a>新生代 VS 老生代</h5><ul>
<li><p>新生代区域垃圾回收使用</p>
<p>空间换时间</p>
<ul>
<li>主要采用复制算法，要有空闲空间存在，当然新生代本身空间小，分出来的复制的空间更小，所以浪费这点空间换取时间的效率是微不足道的</li>
</ul>
</li>
<li><p>老生代区域垃圾回收不适合复制算法，老生代空间大一分为二，会造成一半的空间浪费，存放数据多复制时间长。</p>
</li>
</ul>
<h3 id="增量标记（Incremental-Marking）"><a href="#增量标记（Incremental-Marking）" class="headerlink" title="增量标记（Incremental Marking）"></a>增量标记（Incremental Marking）</h3><ul>
<li><p>前面的三种算法，都需要将正在执行的 JavaScript 应用逻辑暂停下来，待垃圾回收完毕后再恢复。这种行为叫作“全停顿”（stop-the-world）。</p>
</li>
<li><p>在 V8 新生代的分代回收中，只收集新生代，而新生代通常配置较小，且存活对象较少，所以全停顿的影响不大，而老生代就相反了。</p>
</li>
<li><p>为了降低全部老生代全堆垃圾回收带来的停顿时间，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替进行，直到标记阶段完成。</p>
<p><img src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200811005216.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200811005216.png" class="lozad post-image"></p>
<p>经过增量标记改进后，垃圾回收的最大停顿时间可以减少到原来的 1&#x2F;6 左右。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000038461201">垃圾回收机制认识与算法详解</a></li>
<li><a target="_blank" rel="noopener" href="http://newhtml.net/v8-garbage-collection/">V8 之旅：垃圾回收器</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000038461642">JavaScript 引擎 V8 中的垃圾回收机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a8a04fd00c3c">几种垃圾回收算法</a></li>
</ol>

  </div>
  <div>
  
  </div>
</article>
<div class="nav">
  
  <div class="nav-item-prev">
    <a href="/2022/04/06/Node.js基础/" class="nav-link">
      <i class="iconfont icon-left nav-prev-icon"></i>
      <div>
        <div class="nav-label">Prev</div>
        
        <div class="nav-title">Node.js基础 </div>
        
      </div>
    </a>
  </div>
  
  
  <div class="nav-item-next">
    <a href="/2022/04/06/git 命令/" class="nav-link">
      <div>
        <div class="nav-label">Next</div>
        
        <div class="nav-title">git常用命令 </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>TOC</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">JavaScript 垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7"><span class="toc-text">可达性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8"><span class="toc-text">两个引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E4%BA%92%E5%85%B3%E8%81%94%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">相互关联的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="toc-text">无法访问的数据块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%EF%BC%88Mark-Sweep%EF%BC%89"><span class="toc-text">标记 - 清除（Mark-Sweep）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%EF%BC%88Mark-Compact%EF%BC%89"><span class="toc-text">标记 - 整理（Mark-Compact）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%88Reference-Counting%EF%BC%89"><span class="toc-text">引用计数（Reference Counting）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6%EF%BC%9A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-text">限制：循环引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%EF%BC%88Scavenge%EF%BC%89"><span class="toc-text">分代回收（Scavenge）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6"><span class="toc-text">新生代对象回收</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-text">主要使用算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-text">回收过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%8B%E5%8D%87"><span class="toc-text">晋升</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E8%80%81%E7%94%9F%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">回收老生代对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95-1"><span class="toc-text">主要使用算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%A2%9E%E9%87%8F%E4%BC%98%E5%8C%96%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">标记增量优化垃圾回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3-VS-%E8%80%81%E7%94%9F%E4%BB%A3"><span class="toc-text">新生代 VS 老生代</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0%EF%BC%88Incremental-Marking%EF%BC%89"><span class="toc-text">增量标记（Incremental Marking）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol>
</div></main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="/img/logo.png" class="author-img">

<p class="author-name">wuxt</p>
<p class="author-description"></p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>31</span>
    <span>Posts</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>9</span>
    <span>Categories</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>12</span>
    <span>Tags</span>
  </a>
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>TOC</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">JavaScript 垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7"><span class="toc-text">可达性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8"><span class="toc-text">两个引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E4%BA%92%E5%85%B3%E8%81%94%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">相互关联的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="toc-text">无法访问的数据块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%EF%BC%88Mark-Sweep%EF%BC%89"><span class="toc-text">标记 - 清除（Mark-Sweep）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%EF%BC%88Mark-Compact%EF%BC%89"><span class="toc-text">标记 - 整理（Mark-Compact）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%88Reference-Counting%EF%BC%89"><span class="toc-text">引用计数（Reference Counting）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6%EF%BC%9A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-text">限制：循环引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%EF%BC%88Scavenge%EF%BC%89"><span class="toc-text">分代回收（Scavenge）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6"><span class="toc-text">新生代对象回收</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-text">主要使用算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-text">回收过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%8B%E5%8D%87"><span class="toc-text">晋升</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E8%80%81%E7%94%9F%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">回收老生代对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95-1"><span class="toc-text">主要使用算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%A2%9E%E9%87%8F%E4%BC%98%E5%8C%96%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">标记增量优化垃圾回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3-VS-%E8%80%81%E7%94%9F%E4%BB%A3"><span class="toc-text">新生代 VS 老生代</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0%EF%BC%88Incremental-Marking%EF%BC%89"><span class="toc-text">增量标记（Incremental Marking）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>Categories</div>
  <div class="categories-list">
    
      <a href="/categories/常用工具">
        <div class="categories-list-item">
          常用工具
          <span class="categories-list-item-badge">5</span>
        </div>
      </a>
    
      <a href="/categories/JavaScript">
        <div class="categories-list-item">
          JavaScript
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/Nodejs">
        <div class="categories-list-item">
          Nodejs
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/Vue">
        <div class="categories-list-item">
          Vue
          <span class="categories-list-item-badge">7</span>
        </div>
      </a>
    
      <a href="/categories/Typescript">
        <div class="categories-list-item">
          Typescript
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/Mysql">
        <div class="categories-list-item">
          Mysql
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/React">
        <div class="categories-list-item">
          React
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/第三方库">
        <div class="categories-list-item">
          第三方库
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/css">
        <div class="categories-list-item">
          css
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>hot tags</div>
  <div class="tags-list">
    
    <a href="\tags\git" title="git"><div class="tags-list-item">git</div></a>
    
    <a href="\tags\hexo" title="hexo"><div class="tags-list-item">hexo</div></a>
    
    <a href="\tags\express" title="express"><div class="tags-list-item">express</div></a>
    
    <a href="\tags\模板" title="模板"><div class="tags-list-item">模板</div></a>
    
    <a href="\tags\koa" title="koa"><div class="tags-list-item">koa</div></a>
    
    <a href="\tags\eslint" title="eslint"><div class="tags-list-item">eslint</div></a>
    
    <a href="\tags\原理" title="原理"><div class="tags-list-item">原理</div></a>
    
    <a href="\tags\npm" title="npm"><div class="tags-list-item">npm</div></a>
    
    <a href="\tags\vue3" title="vue3"><div class="tags-list-item">vue3</div></a>
    
    <a href="\tags\状态管理" title="状态管理"><div class="tags-list-item">状态管理</div></a>
    
    <a href="\tags\Redux" title="Redux"><div class="tags-list-item">Redux</div></a>
    
    <a href="\tags\bug" title="bug"><div class="tags-list-item">bug</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">
  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>TOC</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">JavaScript 垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7"><span class="toc-text">可达性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8"><span class="toc-text">两个引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E4%BA%92%E5%85%B3%E8%81%94%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">相互关联的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="toc-text">无法访问的数据块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%EF%BC%88Mark-Sweep%EF%BC%89"><span class="toc-text">标记 - 清除（Mark-Sweep）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%EF%BC%88Mark-Compact%EF%BC%89"><span class="toc-text">标记 - 整理（Mark-Compact）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%88Reference-Counting%EF%BC%89"><span class="toc-text">引用计数（Reference Counting）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6%EF%BC%9A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-text">限制：循环引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%EF%BC%88Scavenge%EF%BC%89"><span class="toc-text">分代回收（Scavenge）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6"><span class="toc-text">新生代对象回收</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-text">主要使用算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-text">回收过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%8B%E5%8D%87"><span class="toc-text">晋升</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E8%80%81%E7%94%9F%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">回收老生代对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95-1"><span class="toc-text">主要使用算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%A2%9E%E9%87%8F%E4%BC%98%E5%8C%96%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">标记增量优化垃圾回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3-VS-%E8%80%81%E7%94%9F%E4%BB%A3"><span class="toc-text">新生代 VS 老生代</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0%EF%BC%88Incremental-Marking%EF%BC%89"><span class="toc-text">增量标记（Incremental Marking）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol>
  </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>Recent Posts</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2023-09-09</div>
        <a href="/2023/09/09/touch事件中断/"><div class="recent-posts-item-content">touch事件中断</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2023-09-03</div>
        <a href="/2023/09/03/在vue中使用ts/"><div class="recent-posts-item-content">在vue中使用ts</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2023-09-03</div>
        <a href="/2023/09/03/typescript泛型/"><div class="recent-posts-item-content">typescript泛型</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2023-03-19</div>
        <a href="/2023/03/19/css-auto和100-区别/"><div class="recent-posts-item-content">css auto和100%区别</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>Copyright ©
          
          2022 -
          
          2023
        </span>
        <a href="/" class="footer-link">wuxt </a>
      </div>
    </div>

    
    <div class="footer-dsc">
      
      
      Powered by
      <a href="https://hexo.io/" class="footer-link" target="_blank" rel="nofollow noopener noreferrer">&nbsp;Hexo </a>
      
      
      <span>&nbsp;|&nbsp;</span>
      
      
      
      Theme -
      <a href="https://github.com/theme-kaze" class="footer-link" target="_blank"
        rel="nofollow noopener noreferrer">&nbsp;Kaze</a>
      
    </div>
    
    
    
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton" >
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a role="button" id="darkbutton" class="basebutton darkwidget">
  <i class="iconfont icon-weather button-icon"></i>
</a>

  
  
  
  <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img');
    var i;
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a');
      wrapper.setAttribute('data-fslightbox', 'gallery');
      wrapper.setAttribute('href', img[i].getAttribute('data-src'));
      wrapper.setAttribute('style', 'width: 100%; display: flex; justify-content: center;');
      img[i].parentElement.insertBefore(wrapper, img[i]);
      wrapper.appendChild(img[i]);
    }
    refreshFsLightbox();
  }
</script>
<script>loadScript("//cdn.jsdelivr.net/npm/fslightbox@3.1.0/index.min.js", addImgLayout)</script>
  
  
  
<script src="/js/main.js"></script>

  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  
</body>

</html>